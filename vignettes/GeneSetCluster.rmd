---
title: "GeneSetCluster"
author: "Ewoud Ewing"
date: "06/05/2019"
output:
    BiocStyle::html_document:
        toc: true
        fig_retina: false
vignette: >
    %% \VignetteEngine{knitr::rmarkdown}
    %% \VignetteIndexEntry{GeneSetCluster User's Guide}
---



```{r setup, include=FALSE}
require(GeneSetCluster)

```

# GeneSetCluster Package example data
This is the demonstration of the R package GeneSetCluster

This is a package meant to be used to cluster together Gene-Sets from pathway tools such as Ingenuity Pathway Aanalysis (IPA) (https://www.qiagenbioinformatics.com/products/ingenuity-pathway-analysis/) and GREAT (http://great.stanford.edu/public/html/index.php). Gene-Sets often appear significant when running such tools with different labels displaying different Gene-Sets.

However, it can become difficult to interpret the output sometimes when the data of several gene sets compared. Furthermore the output data has several limitations: 
1)	Low ratio: where there are only a few genes enriched. 
2)	High similarity: where the different genes sets that appear have the same genes enriched despite the different labels. 
3)	Low overlap: where the same gene set labels appear in different experimental settings but different genes are enriched. 

So its better to review theses sets of genes together instead of investigating the many different Gene-Sets individually. This package does this by taking the sets of genes of every Gene-Set and calculates the Relative Risk of them appearing together. This is used as a distance between them, the higher it is the greater overlap they have. This distance score is then used to cluster the Gene-Sets together.

The data is taken from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE111385
Data has been analysed with Deseq2 pipeline where the data is Transcriptome sequencing of WT and conditional-Tgfbr2 knockout microglia and CNS-repopulating monocyte-derived macrophages from C57BL/6 mouse in triplicates. The genes were picked in a comparison of uG vs Mac in both WT and KO with a 1E-06 pvalue cutoff. Genes were analysed in both IPA with the Canonical pathways and functional annotations were exported into a excel file with default settings. 
Bed files were also generated for the genes, and uploaded in GREAT with a background of the sequencing samples. All data was exported in tsv format. 

Exported files were stored in the files: ~/Project9/ProjectData_MM10/GREAT/ and ~/Project9/ProjectData_MM10/IPA/

##Pipeline  
![Pipeline of the Package](img/Pipeline.png)

##Loading the data
We start with creating the PathwayObject. This can be done using the automatic loader (LoadGeneSets) or with ObjectCreator. ObjectCreator needs just a vector of Gene-Sets labels, a vector with genes (as a string for each Gene-Set), a vector with each group every Gene-Set belongs to (e.g. KO or WT), it needs the Source (e.g. IPA), it needs the Type (e.g. Canonical pathways), structure (e.g. SYMBOL), and seperator (sep) (How is are the strings of the genes seperated). Gene-Sets labels, Genes and Groups need the same length. Everything else is just a single string. See example below in 1.7.

The LoadGeneSets function has all this automated, currently the LoadGeneSets function supports loading GREAT TSV files (As exported as "all data as TSV").
![exporting GREAT](img/Great.png)


As well as IPA canonical pathways (exported as excel) or Functional annotations (exported as excel).

![exporting IPA](img/IPA.PNG)


The remaining info includes: Pvalue cutoff, the minimum number of molecules per Gene-Set (Recommended >= 5), The source, if great was run with a background, the type for GREAT doenst matter as it runs 18 diferent types that the loader automatically assigns. But for IPA its important. The great output is really really large. Recommended is that the topranks be given. Meaning you only look at the top Gene-Sets. The structure structure (e.g. SYMBOL, this is important as the combinePathways check that all the data is in the same structure). As well as the organims (so it can correctly convert the structure, the name has to be of the name of the package installed of which to call. Currently supported is the org.Mm.eg.db and org.Hs.eg.db packages). Last but not least is the seperator. How are the genes combined in a string. 

##Loading GREAT
###Loading GREAT data

```{r Great with Background load }

Great.files <- c(system.file("extdata", "MM10.GREAT.KO.uGvsMac.bed.tsv", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.GREAT.KO.uGvsMac.bed_BCKGRND.tsv", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.GREAT.WT.uGvsMac.bed.tsv", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.GREAT.WT.uGvsMac.bed_BCKGRND.tsv", package = "GeneSetCluster"))
Great.files.bckgrnd <- Great.files[grepl("BCKGRND", Great.files)]


Great.bckgnrd.Object1 <- LoadGeneSets(file_location = Great.files.bckgrnd, 
                              groupnames= c("KO", "WT"),
                              P.cutoff = 0.05, 
                              Mol.cutoff = 5,
                              Source = "Great",
                              Great.Background = T,#specify the background, as great has a different output if run with or without background
                              type = "Canonical_Pathways",
                              topranks = 20,#Great gives soo much output, recommended is adding a topranks filter for first 20
                              structure = "SYMBOL",
                              Organism = "org.Mm.eg.db",
                              seperator = ",")


```


###Plot Overlap of Gene-Sets labels
Here we can see the overlap between the different labels in the Disease Ontology output
```{r Venndiagram, echo=FALSE}
par(mfrow=c(2,1))
VennDiagram(n_groups = 2, 
               Group1 = as.character(Great.bckgnrd.Object1@Data$`KO_GO Cellular Component`$Pathways), 
               Group2 =as.character(Great.bckgnrd.Object1@Data$`KO_GO Cellular Component`$Pathways), 
               names_groups = c("KO", "WT"),
               main = "Overlapping GO Cellular Component",legend = F, percentage = F )

VennDiagram(n_groups = 2, 
               Group1 = as.character(Great.bckgnrd.Object1@Data$`KO_GO Biological Process`$Pathways), 
               Group2 =as.character(Great.bckgnrd.Object1@Data$`WT_GO Biological Process`$Pathways), 
               names_groups = c("KO", "WT"),
               main = "Overlapping GO Biological Process",legend = F, percentage = F )
```

###Investigate the metafiles
Does this look like the experiment that we designed?
```{r Great with Background meta }

ShowExperimentdata(Object =Great.bckgnrd.Object1 )
ShowMeta(Object = Great.bckgnrd.Object1 )

```
###Manage Gene-Sets
If the data is as desired, you can continue with the combinePathway function, if not we can select types of interest using managePathways. In this case we are interested in Disease Ontology and Go Biological Process, so we managePathways to keep those data types and remove the others.

```{r Great with Background manage clusters}

man.Great.Object1 <- ManageGeneSets(Object = Great.bckgnrd.Object1, keep.type =c("Disease Ontology","GO Biological Process" ), exclude.type="")


ShowExperimentdata(Object =man.Great.Object1 )
ShowMeta(Object =man.Great.Object1 )
```
###Combine and cluster
Here we combine and cluster the Gene-Sets. The CombineGeneSets function  calculates the distance between Gene-Sets which is further used for clustering. The distance by default is a Relative Risk (RR), however if desired a user supplied functuon can also be provided (see 1.4.6). The clustering can be done in 6 ways, kmeans, Kmeans per group, mclust, mclust per group, hierarchical, and hierarchical per group. depending on the data different clustering methods work better.

```{r Great with Background combine and cluster }

man.Great.Object2 <- CombineGeneSets(Object = man.Great.Object1)
man.Great.Object3 <- ClusterGeneSets(Object = man.Great.Object2, 
                                 clusters = 5, 
                                 method = "kmeans")
```

###Plot The great RR with background clusters
Using the PlotPathways function Object3 can be plotted into a heatmap with a bar for Group and cluster, allowing you to identify the groups. If desired you can add the annotation of the genes and Gene-Sets names using annotation.mol. Also the data is scaled. When there are very large Gene-Sets involved the scales of the RR can be very large. E.g. some Gene-Sets have a RR of >750 while other small ones are ~30. This makes it difficult to distuingish the different clusters. Use the RRmax function to scale the RR to the max desired. 


```{r plotPathways, echo=FALSE}
PlotGeneSets(Object =man.Great.Object3, fontsize = 3,
            legend = T,
            annotation.mol=F,
            main="Great_Background clustered with Kmeans without scaling \n Disease Ontology and GO Biological Process")

PlotGeneSets(Object =man.Great.Object3, fontsize = 3,
            legend = T,
            annotation.mol=F,
            RR.max = 60,
            main="Great_Background clustered with Kmeans \n Disease Ontology and GO Biological Process")
```
Here we can see there there are 5 clusters and while there are overlapping sets of genes between the different experiments, within each experiment there are several clusters which would make more sense to view together, in this case there are 5 sets to investigate because kmeans was set to 5, but every data sets needs to be investigated to identify the optimal number of clusters. Mclust can find the optimal number of clusters required but you can set an maximum. 


##IPA
###Loading IPA data
When Loading IPA data we seperate between Canonical Pathways and Functional Anotations. 

```{r load IPA}


IPA.files <- c(system.file("extdata", "MM10.IPA.KO.uGvsMac.Canonical_pathways.xls", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.IPA.WT.uGvsMac.Canonical_pathways.xls", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.IPA.KO.uGvsMac.Functional_annotations.xls", package = "GeneSetCluster"),
                 system.file("extdata", "MM10.IPA.WT.uGvsMac.Functional_annotations.xls", package = "GeneSetCluster"))
canonical.files <- IPA.files[grep("Canonical", IPA.files)]

IPA.object1 <- LoadGeneSets(file_location = canonical.files, #where are  the files
                            groupnames= c("KO", "WT"),#Names of the groups 
                            P.cutoff = 1.3, #minumum cutoff if smaller than 1 it assumes normal pvalue, if larger than 1 it assumes a log10 palue
                            Mol.cutoff = 5,# amount of molecules interested in 
                            Source = "IPA",#How was the data generated
                            type = "Canonical_Pathways",#What is the experiment e.g. canonical pathways, functional anotation
                            structure = "SYMBOL",#structure of the molecules e.g. genenames, ensembl_ID etc 
                            seperator = ",")#How are the genes seperated

```
###Plot Overlap of pathway labels
Here we can see the overlap between the different labels in the IPA canonical output.

Nearly all the labels from KO are in the WT experiment. But lets see if based on the genes within those labels thats still true, if those Gene sets cluster together.


```{r Venndiagram IPA Pathways, echo=FALSE}
VennDiagram(n_groups = 2, 
               Group1 = as.character(IPA.object1@Data$KO$Pathways), 
               Group2 =as.character(IPA.object1@Data$WT$Pathways), 
               names_groups = c("KO", "WT"),
               main = "Overlapping IPA pathway labels",legend = F, percentage = F )



```
###IPA canonical meta
Here we can see the overlap between the different labels in the IPA canonical output


```{r meta IPA Pathways}
ShowExperimentdata(Object =IPA.object1 )
ShowMeta(Object =IPA.object1 )


```
###IPA Combining and clustering canonical Gene-Sets
Here we combine and cluster the IPA output using kmeans.

```{r combine and cluseter IPA Pathways}

IPA.object2 <- CombineGeneSets(Object = IPA.object1)

IPA.object3 <- ClusterGeneSets(Object = IPA.object2, 
                               clusters = 12, 
                               method = "kmeans")

```
###Highlighting genes
When running the data we can ask it wether a certain set of genes ar emore appearing in certain clusters than others. To view this we can take a gene set and highlight it in the data. In the plot an extra bar will appear where the higher the overlap the darker blue it becomes. 

```{r Highlight IPA Canonical Pathways}

#Highlighting Redox Genes
system.file("data", "Redox.genes.rda", package = "testdat")
IPA.object3.highlight <- HighlightGeneSets(Object = IPA.object3, highligt.genes = Redox.genes, name = "Ros")

```
###Plot The IPA canonical RR with highlights clusters


```{r PlotPathways with highlight, echo=FALSE}

PlotGeneSets(Object =IPA.object3.highlight, fontsize = 3,
            legend = T,
            annotation.mol=F,
            RR.max = 60,
            main="IPA canonical RR with highlights clusters")
```


###Distance calculations using user supplied combinations functions
calcuating the distance between Gene-Sets is by default by calcuting the RR. However in certain cases the user wants to use a different function to comine the data. The function alows to use a user supplied functions. e.g. the jaccard similarity index can be used, this calculated the overlap between Gene-sets. Jaccard is quite suitable for larger Gene-Sets but biased in smaller Gene-Sets. 

```{r User supplied distance calculations}

jaccard <- function(A,B)
{
  #The Jaccard similarity index (sometimes called the Jaccard similarity coefficient) compares members 
  #for two sets to see which members are shared and which are distinct. 
  #It's a measure of similarity for the two sets of data, with a range from 0% to 100%. 
  #The higher the percentage, the more similar the two populations.
  
  M <- sum(as.vector(A) == 1 & as.vector(B) == 1)
  A.c <- sum(as.vector(A) == 1 & as.vector(B) == 0)
  B.c <- sum(as.vector(A) == 0 & as.vector(B) == 1)
  J <- M/(A.c+B.c+M)
  return(J)
}


IPA.Object.J <- CombineGeneSets(Object = IPA.object1, combineMethod = "Jaccard", combineMethod.supplied = jaccard)
IPA.Object.J <- ClusterGeneSets(Object = IPA.Object.J, 
                                                clusters = 4, 
                                                method = "kmeans", 
                                                order = "group")

PlotGeneSets(Object = IPA.Object.J, fontsize =5,
            legend = T,
            annotation.mol=F,
            main="Jaccard distance", RR.max = 50)
```


##Loading the IPA functional annotations 
GeneSetCluster can load many types of data, including Canonical Pathways it can also automatically load Functional annotations. 
Specify in the loader that these are functional annotations and set the Pvalue cutoff accordingly. Using default settings Canonical pathways are exported with -log10 transformed Pvalues, meaning the larger is more significant, while functional annotations are exported with untransformed pvalues. 


```{r load IPA functional annotations}

################################################
#-------IPA on Functional_annotations----------#
################################################


functional.files <- IPA.files[grep("Functional", IPA.files)]

IPA.Functional.object1 <- LoadGeneSets(file_location = functional.files, #where are  the files
                                 groupnames= c("KO", "WT"),#Names of the groups 
                                 P.cutoff = 0.05, #minumum cutoff if smaller than 1 it assumes normal pvalue, if larger than 1 it assumes a log10 palue
                                 Mol.cutoff = 5,# amount of molecules interested in 
                                 Source = "IPA",#How was the data generated
                                 type = "Functional_annotations",#What is the experiment e.g. canonical pathways, Functional_annotations
                                 structure = "SYMBOL",#structure of the molecules e.g. genenames, ensembl_ID etc 
                                 seperator = ",")#How are the genes seperated
```

###Plot Overlap of functions labels
Here we can see the overlap between the different labels in the IPA functional output
Many functional annotations labels are shared. 

```{r Venndiagram IPA functions}
VennDiagram(n_groups = 2, 
               Group1 = as.character(IPA.Functional.object1@Data$KO$Pathways), 
               Group2 =as.character(IPA.Functional.object1@Data$WT$Pathways), 
               names_groups = c("KO", "WT"),
               main = "Overlapping IPA functions labels",legend = F, percentage = F )



```
###IPA functional meta
Here we can see the overlap between the different labels in the IPA functional output. They should reflect the experiments accordingly. 

```{r meta IPA functional}

ShowExperimentdata(Object =IPA.Functional.object1 )
ShowMeta(Object = IPA.Functional.object1 )


```

###IPA Combining and clustering functional Gene-Sets
Here we combine and cluster the IPA functional output using mclust. Here the are a maximum number of clusters is 12, but mclust determines that the optimal clustering is 8 clusters. 

```{r combine and cluseter IPA functional Gene-Sets}

IPA.Functional.object2 <- CombineGeneSets(Object = IPA.Functional.object1)

IPA.Functional.object3 <- ClusterGeneSets(Object = IPA.Functional.object2, 
                               clusters = 12, 
                               method = "mclust")

```
###Plot The IPA functional RR
Plotting the different Pathways where you can see the different clusters.  This time using mclust. 

```{r plotPathways with functional, echo=FALSE}

PlotGeneSets(Object = IPA.Functional.object3, 
            fontsize = 3,
            legend = T,
            annotation.mol=F,
            RR.max = 60,
            main="IPA functional RR with mclust clusters")
```

##Merging the canonical pathways and functional annotations
When we have 2 datasets and we want to compare, we can merge together 2 object1 files into an merged object1. This way we can compare the different datasets. But also between different tools, e.g. IPA and Great outputs can be compared.  It warns when different tools or types are merged.


```{r merge datasets IPA}

Ipa.merged.object1 <- MergeObjects(Object.1 =IPA.object1, 
                                    Object.2 = IPA.Functional.object1)



ShowExperimentdata(Object =Ipa.merged.object1 )
ShowMeta(Object = Ipa.merged.object1 )

```
###Combine and cluster merged data
We can now combine and cluster the results. Of note here is of course the time it takes growths exponentially with larger datasets, so the merged data takes longer than the seperate data sets.

```{r merge datasets combine and cluster IPA}

Ipa.merged.object2 <- CombineGeneSets(Object = Ipa.merged.object1)

Ipa.merged.object3 <- ClusterGeneSets(Object = Ipa.merged.object2, 
                                          clusters = 12, 
                                          method = "kmeans")

```


###Merged Data in Object3
Now the data sets are merged and compared. 
These are completely normal Objects now. So we can also highlight the object same as we done before.

```{r highlight dataset merged}
Ipa.merged.object3.highlight <- HighlightGeneSets(Object = Ipa.merged.object3, highligt.genes = Redox.genes, name = "Ros")

```

###Plot The IPA merged RR

We can plot these results from the highlighted merged 12 kmeans clusters.

In the heatmap:


```{r plotPathways with merged, echo=FALSE}

PlotGeneSets(Object =Ipa.merged.object3.highlight, fontsize = 3,
            legend = T,
            annotation.mol=F,
            RR.max = 60,
            main="IPA merged RR with highlights clusters")
```


##Export the combined pathways and RR

We can say we want just the clustered pathways, or we want to have a look at both the RR and the clustered pathways. It writes it in the folder assigned to file_location and it takes the name of Name and writes it into a CSV file with seperation of ";", to make it readable by Excel.


```{r write merged output to file}

WriteGeneSets(Object = Ipa.merged.object3.highlight, file_location = "~/Project9/ProjectData_MM10/", name = "Ipa.merged.object3.highlight", write = "Both")
```


##Creating object with custom table
When data wasnt run in GREAT or IPA the aproach can still be used. In fact it doesnt neccesary need to be proper pathways. The thing the code needs is a group, a name, and name content. Plus some meta info. We can also simulate a dataset.


###Creating random pathway data

We can create a random data set. Assign the names as Pathway_1 etc. With the genes inside just being Gene_1 to Gene_200.
```{r Creating random pathway data}

Test.object <- matrix(data = NA, nrow = 50, ncol = 3)
colnames(Test.object) <- c("Pathways", "Genes", "Group")
Test.object[,"Pathways"] <- paste("Pathway", 1:nrow(Test.object), sep = "_")
Test.object[1:25,"Group"] <- "Group1"
Test.object[26:50,"Group"] <- "Group2"


#Create a random amount of genes per pathway
random.gene <- function()
{
  genenames <- paste("Gene", 1:200, sep = "_")#this gives 200 gene names
  genes <- round(runif(n = runif(n = 1,min =  7,max = 20), min = 1, max = 200), digits = 0)#This gives between 7 and 20 random whole numbers
  genes <- unique(genes)#remove duplicate numbers             
  genes <- genenames[genes]#get random genesnames
  return(genes)
}

for(i in 1:nrow(Test.object))
{
  Test.object[i, "Genes"] <- paste(random.gene(), collapse=",")#Collapse the genes into a string
}

head(Test.object)
```


###Creating object with custom table
We can input this in the Object creator to generate a proper GeneSetCluster Object. 
```{r creating random pathway Object}

Test.object1 <- ObjectCreator(Pathways = Test.object[,1], 
                              Molecules = Test.object[,2], 
                              Groups = Test.object[,3],
                              Source = "Random",#we randomly generated this data
                              type = "Test",
                              structure = "SYMBOL",
                              sep = ",")#neccesay to seperate the different genes for combinations.
ShowExperimentdata(Object = Test.object1)
ShowMeta(Object = Test.object1)
```


###Creating Combine and clustering custom object
The combining and clustering works exactly the same as autoloaded objects.

```{r combining and clustering custom Object}
Test.object2 <- CombineGeneSets(Object = Test.object1)
Test.object3 <- ClusterGeneSets(Object = Test.object2, 
                                                clusters = 4, 
                                                method = "kmeans", 
                                                order = "group")

```


###Plotting custom Object
The plotting works the same as any other object3. 
Note there are few clusters visible because the data is random. 

```{r plotting random Object}
PlotGeneSets(Object = Test.object3, fontsize =5,
            legend = T,
            annotation.mol=F,
            main="Random genes", RR.max = 50)

```

